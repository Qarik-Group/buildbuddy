syntax = "proto3";

import "proto/remote_execution.proto";
import "google/rpc/status.proto";

package raft;

////////////////////////////////////////////////////////////////////////////////
//
// Raft storage and wire protos, used to represent data written to the raft log.
//
////////////////////////////////////////////////////////////////////////////////

// KV is a basic proto type that represents data written to pebble.
message KV {
  bytes key = 1;
  bytes value = 2;
}

// Isolation represents the cache isolation type of a particular item.
message Isolation {
  enum CacheType {
    UNKNOWN_TYPE = 0;
    ACTION_CACHE = 1;
    CAS_CACHE = 2;
  }
  CacheType cache_type = 1;
  string remote_instance_name = 2;
}

message FileRecord {
  string group_id = 1;
  Isolation isolation = 2;
  build.bazel.remote.execution.v2.Digest digest = 3;
}

message FileWriteRequest {
  FileRecord file_record = 1;
}

message FileWriteResponse {}

message DirectWriteRequest {
  KV kv = 1;
}

message DirectWriteResponse {}

message DirectReadRequest {
  bytes key = 1;
}

message DirectReadResponse {
  KV kv = 1;
}

message IncrementRequest {
  bytes key = 1;
  uint64 delta = 2;  // how much to increment by.
}

message IncrementResponse {
  bytes key = 1;
  uint64 value = 2;
}

message ScanRequest {
  bytes left = 1;
  bytes right = 2;

  enum ScanType {
    UNDEFINED_SCAN_TYPE = 0;
    SEEKLT_SCAN_TYPE = 1;
    SEEKGE_SCAN_TYPE = 2;
  }
  ScanType scan_type = 3;
}

message ScanResponse {
  repeated KV kvs = 1;
}

// Raft CMD API, used to encode raft commands that are replicated via raft and
// written to a log. Everything written via SyncPropose must be a RequestUnion
// wrapped in a BatchCmdRequest..
message RequestUnion {
  oneof value {
    FileWriteRequest file_write = 1;
    DirectWriteRequest direct_write = 2;
    DirectReadRequest direct_read = 3;
    IncrementRequest increment = 4;
    ScanRequest scan = 5;
  }
}

// Raft CMD API, used to encode raft commands that are replicated via raft and
// written to a log. Everything passed to SyncRead must be a RequestUnion
// wrapped in a BatchCmdRequest and everything returned will be a
// BatchCmdResponse.
message ResponseUnion {
  google.rpc.Status status = 1;

  oneof value {
    FileWriteResponse file_write = 2;
    DirectWriteResponse direct_write = 3;
    DirectReadResponse direct_read = 4;
    IncrementResponse increment = 5;
    ScanResponse scan = 6;
  }
}

message BatchCmdRequest {
  repeated RequestUnion union = 1;
}

message BatchCmdResponse {
  repeated ResponseUnion union = 2;
}

////////////////////////////////////////////////////////////////////////////////
//
// Gossip API, data that is broadcast / consumed via the gossip network.
//
////////////////////////////////////////////////////////////////////////////////
message RegistryUpdate {
  message Add {
    uint64 cluster_id = 1;
    uint64 node_id = 2;
    string target = 3;
  }
  repeated Add adds = 1;

  message Remove {
    uint64 cluster_id = 1;
    uint64 node_id = 2;
    string target = 3;
  }
  repeated Remove removes = 2;

  message RemoveCluster {
    uint64 cluster_id = 1;
  }
  repeated RemoveCluster cluster_removes = 3;

  string nhid = 4;
  string grpc_address = 5;
  string raft_address = 6;
}

// A RegistryQuery can be sent to gossip to resolve a node, the response
// will be a RegistryUpdate with only Adds.
message RegistryQuery {
  uint64 cluster_id = 1;
  uint64 node_id = 2;
}

// The auto-bringup protocol is very simple: if no previous data is found on
// startup, the first node in the sorted "join" set will query other nodes
// until it finds all other members of the join set. If they have previous data
// then they do not respond to the bringup query. If all nodes respond, then
// the first node sends them a StartCluster request and provisions the initial
// cluster.
message BringupResponse {
  string nhid = 1;
  string grpc_address = 2;
}

////////////////////////////////////////////////////////////////////////////////
//
// Raft meta-API, used by placement driver to manage data locations etc.
//
////////////////////////////////////////////////////////////////////////////////

message NodeDescriptor {
  string nhid = 1;
  string raft_address = 2;
  string grpc_address = 3;

  repeated ReplicaDescriptor replica_descriptor = 4;
}

message ReplicaDescriptor {
  uint64 cluster_id = 1;
  uint64 node_id = 2;
}

message RangeSet {
  repeated RangeDescriptor ranges = 1;
}

message RangeDescriptor {
  bytes left = 1;
  bytes right = 2;

  uint64 range_id = 3;
  repeated ReplicaDescriptor replicas = 4;

  uint64 generation = 5;
}

// SyncPropose, in proto form.
message SyncProposeRequest {
  ReplicaDescriptor replica = 1;

  BatchCmdRequest batch = 2;
}

message SyncProposeResponse {
  BatchCmdResponse batch = 1;
}

// SyncRead, in proto form.
message SyncReadRequest {
  ReplicaDescriptor replica = 1;
  BatchCmdRequest batch = 2;
}
message SyncReadResponse {
  BatchCmdResponse batch = 1;
}

message StartClusterRequest {
  uint64 cluster_id = 1;
  uint64 node_id = 2;
  map<uint64, string> initial_member = 3;

  // The following commands will be SyncProposed on the local
  // nodehost after the cluster has been created.
  BatchCmdRequest batch = 4;
}

message StartClusterResponse {
  BatchCmdResponse batch = 1;
}

////////////////////////////////////////////////////////////////////////////////
//
// Data backhaul API, used for shipping the actual bytes around, outside raft.
//
////////////////////////////////////////////////////////////////////////////////

message ReadRequest {
  FileRecord file_record = 1;
  int64 offset = 2;
}

message ReadResponse {
  bytes data = 1;
}

message WriteRequest {
  FileRecord file_record = 1;
  bool finish_write = 2;
  bytes data = 3;
}

message WriteResponse {
  int64 committed_size = 1;
}
